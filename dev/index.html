<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Brim.Net Core Package &mdash; Brim.Net Core Package 0.05 documentation</title>
    
    <link rel="stylesheet" href="_static/brim.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.05',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Brim.Net Core Package 0.05 documentation" href="#" />
    <link rel="next" title="README" href="readme.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="readme.html" title="README"
             accesskey="N">next</a> |</li>
        <li><a href="#">Brim.Net Core Package 0.05 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="brim-net-core-package">
<h1>Brim.Net Core Package<a class="headerlink" href="#brim-net-core-package" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Version 0.05 is considered a development version.</p>
</div>
<p>Latest documentation is always available at <a class="reference external" href="http://gholt.github.io/brim/">http://gholt.github.io/brim/</a></p>
<p>Source code available at <a class="reference external" href="http://github.com/gholt/brim/">http://github.com/gholt/brim/</a></p>
<blockquote>
<div><p>Copyright 2012-2014 Gregory Holt</p>
<p>Portions (httpform) Copyright 2011 OpenStack, LLC.</p>
<p>Licensed under the Apache License, Version 2.0 (the &#8220;License&#8221;); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<blockquote>
<div><a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></div></blockquote>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &#8220;AS IS&#8221; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
</div></blockquote>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="readme.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">LICENSE</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">AUTHORS</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">CHANGELOG</a></li>
<li class="toctree-l1"><a class="reference internal" href="brimdconfsample.html">Sample brimd.conf</a></li>
</ul>
</div>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a prerelease version of this project. As such, even as the author I don&#8217;t completely trust this code yet. It works for the specific cases I&#8217;ve tested, but it needs more use cases and time to prove itself reliable. If you find any problems or possible &#8220;oddities&#8221;, please file issues on github: <a class="reference external" href="http://github.com/gholt/brim">http://github.com/gholt/brim</a> Thanks, and be careful!</p>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">brim</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.conf">brim.conf</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.daemon_sample">brim.daemon_sample</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.http">brim.http</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.httpform">brim.httpform</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.log">brim.log</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.server">brim.server</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.service">brim.service</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.tcp_echo">brim.tcp_echo</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.udp_echo">brim.udp_echo</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.util">brim.util</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.wsgi_basic_auth">brim.wsgi_basic_auth</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.wsgi_echo">brim.wsgi_echo</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.wsgi_fs">brim.wsgi_fs</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-brim.wsgi_stats">brim.wsgi_stats</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="overview">
<span id="id1"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This is the core package for Brim.Net Python-based applications.</p>
<p>It provides some reusable utility code and provides brimd, a launcher offering ease of deployment of WSGI applications (currently just using the Eventlet WSGI server), straight TCP and UDP socket applications, and maintaining background daemons.</p>
<p>The brimd server will spawn subprocesses to handle requests and start daemons allowing for use of multiple CPU cores and for resiliency &#8211; when a subprocess exits without being requested to, it will be restarted automatically.</p>
<div class="section" id="required-dependencies">
<h3>Required Dependencies<a class="headerlink" href="#required-dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://python.org/">Python &gt;= 2.7</a> Not tested with Python 3 yet.</li>
<li><a class="reference external" href="http://eventlet.net/">Eventlet &gt;= 0.14.0</a></li>
<li>Unix platform: This should run on any Unix platform, though only tested on Ubuntu 12.04 LTS to date.</li>
</ul>
</div>
<div class="section" id="optional-dependencies">
<h3>Optional Dependencies<a class="headerlink" href="#optional-dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://code.google.com/p/py-setproctitle/">SetProcTitle</a> If this is installed, brimd will change its process titles to be more meaningful.</li>
<li><a class="reference external" href="https://github.com/simplejson/simplejson">SimpleJSON</a> or other JSON library containing json.dumps and json.loads compatible functions. You can configure brimd to use these alternate libraries if you wish and complying apps and daemons will also use the alternate libraries.</li>
<li><a class="reference external" href="https://pypi.python.org/pypi/py-bcrypt">Py-BCrypt</a> to make use of <a class="reference internal" href="api.html#module-brim.wsgi_basic_auth" title="brim.wsgi_basic_auth"><tt class="xref py py-mod docutils literal"><span class="pre">brim.wsgi_basic_auth</span></tt></a>.</li>
</ul>
</div>
</div>
<div class="section" id="usage-examples">
<h2>Usage Examples<a class="headerlink" href="#usage-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="example-wsgi-usage">
<h3>Example WSGI Usage<a class="headerlink" href="#example-wsgi-usage" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Create ~/.brimd.conf:</p>
<div class="highlight-python"><pre>[wsgi]
port = 8901
apps = echo stats

[echo]
call = brim.wsgi_echo.WSGIEcho

[stats]
call = brim.wsgi_stats.WSGIStats</pre>
</div>
</li>
<li><p class="first">Start the server:</p>
<div class="highlight-python"><pre>$ brimd start</pre>
</div>
</li>
<li><p class="first">Access the &#8220;echo&#8221; app (echos <em>Just a test.</em> back):</p>
<div class="highlight-python"><pre>$ curl -i http://127.0.0.1:8901/echo --data-binary 'Just a test.'</pre>
</div>
</li>
<li><p class="first">Access a non-existent path (404s):</p>
<div class="highlight-python"><pre>$ curl -i http://127.0.0.1:8901/invalid</pre>
</div>
</li>
<li><p class="first">Access the &#8220;stats&#8221; app (returns JSON formatted server stats):</p>
<div class="highlight-python"><pre>$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool</pre>
</div>
</li>
<li><p class="first">Stop the server:</p>
<div class="highlight-python"><pre>$ brimd stop</pre>
</div>
</li>
</ul>
<p>Run <tt class="docutils literal"><span class="pre">brimd</span> <span class="pre">-h</span></tt> for more details on server control. It supports the standard init.d-style commands as well a special no-daemon mode for debugging.</p>
<p>Also, see the included <a class="reference internal" href="brimdconfsample.html#brimdconfsample"><em>brimd.conf-sample</em></a> for a full set of configuration options available, such as the ip and port to use, number of subprocesses (workers), the user/group to run as, subdaemons to start, etc.</p>
</div>
<div class="section" id="example-wsgi-multi-configuration-usage">
<h3>Example WSGI Multi-Configuration Usage<a class="headerlink" href="#example-wsgi-multi-configuration-usage" title="Permalink to this headline">¶</a></h3>
<p>You can even set up multiple listening address or ports and control them with a single brimd, if you want. This can also be achieved with separate conf files and the -c and -p command line options to brimd, but most should find it easier to have one configuration with additional subconfigs. For example:</p>
<ul>
<li><p class="first">Create ~/.brimd.conf:</p>
<div class="highlight-python"><pre>[wsgi]
port = 8901
apps = echo stats

[wsgi#alternate]
port = 8902
apps = echo2 stats

[echo]
call = brim.wsgi_echo.WSGIEcho

[stats]
call = brim.wsgi_stats.WSGIStats

[echo2]
call = brim.wsgi_echo.WSGIEcho
path = /echo2</pre>
</div>
</li>
</ul>
<p>You can see the new section [wsgi#alternate] that defines the second listening port with its own configuration of the echo app and the shared stats configuration.</p>
<ul>
<li><p class="first">Start the server:</p>
<div class="highlight-python"><pre>$ brimd start</pre>
</div>
</li>
<li><p class="first">Access the &#8220;echo&#8221; app on the main port:</p>
<div class="highlight-python"><pre>$ curl -i http://127.0.0.1:8901/echo --data-binary 'Just a test.'</pre>
</div>
</li>
<li><p class="first">Access the &#8220;echo&#8221; app on the second port:</p>
<div class="highlight-python"><pre>$ curl -i http://127.0.0.1:8902/echo2 --data-binary 'Just a test.'</pre>
</div>
</li>
<li><p class="first">Note that the apps don&#8217;t answer on the other ports:</p>
<div class="highlight-python"><pre>$ curl -i http://127.0.0.1:8901/echo2 --data-binary 'Just a test.'
$ curl -i http://127.0.0.1:8902/echo --data-binary 'Just a test.'</pre>
</div>
</li>
<li><p class="first">Access the &#8220;stats&#8221; app and see it&#8217;s configured on both ports:</p>
<div class="highlight-python"><pre>$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
$ curl -s http://127.0.0.1:8902/stats | python -mjson.tool</pre>
</div>
</li>
<li><p class="first">Stop the server:</p>
<div class="highlight-python"><pre>$ brimd stop</pre>
</div>
</li>
</ul>
<p>The included <a class="reference internal" href="brimdconfsample.html#brimdconfsample"><em>brimd.conf-sample</em></a> shows a full set of configuration options available for each subconfig and explains how the defaults usually fall back to the main conf.</p>
</div>
<div class="section" id="example-tcp-straight-socket-application-usage">
<h3>Example TCP Straight Socket Application Usage<a class="headerlink" href="#example-tcp-straight-socket-application-usage" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Create ~/.brimd.conf:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">tcp</span><span class="p">]</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8903</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">brim</span><span class="o">.</span><span class="n">tcp_echo</span><span class="o">.</span><span class="n">TCPEcho</span>
</pre></div>
</div>
</li>
<li><p class="first">Start the server:</p>
<div class="highlight-python"><pre>$ brimd start</pre>
</div>
</li>
<li><p class="first">Access the &#8220;echo&#8221; app (echos <em>Just a test.</em> back):</p>
<div class="highlight-python"><pre>$ echo 'Just a test.' | nc -q 2 127.0.0.1 8903</pre>
</div>
</li>
<li><p class="first">Stop the server:</p>
<div class="highlight-python"><pre>$ brimd stop</pre>
</div>
</li>
<li><p class="first">Create a multi-port ~/.brimd.conf:</p>
<div class="highlight-python"><pre>[tcp]
port = 8903
call = brim.tcp_echo.TCPEcho

[tcp#alternate]
port = 8904
call = brim.tcp_echo.TCPEcho</pre>
</div>
</li>
<li><p class="first">Start the server:</p>
<div class="highlight-python"><pre>$ brimd start</pre>
</div>
</li>
<li><p class="first">Access the &#8220;echo&#8221; apps (echo <em>Just a test.</em> back):</p>
<div class="highlight-python"><pre>$ echo 'Just a test.' | nc -q 2 127.0.0.1 8903
$ echo 'Just a test.' | nc -q 2 127.0.0.1 8904</pre>
</div>
</li>
<li><p class="first">Stop the server:</p>
<div class="highlight-python"><pre>$ brimd stop</pre>
</div>
</li>
</ul>
<p>The included <a class="reference internal" href="brimdconfsample.html#brimdconfsample"><em>brimd.conf-sample</em></a> shows a full set of configuration options available for each subconfig and explains how the defaults usually fall back to the main conf.</p>
</div>
<div class="section" id="example-udp-application-usage">
<h3>Example UDP Application Usage<a class="headerlink" href="#example-udp-application-usage" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Create ~/.brimd.conf:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">udp</span><span class="p">]</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8905</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">brim</span><span class="o">.</span><span class="n">udp_echo</span><span class="o">.</span><span class="n">UDPEcho</span>
</pre></div>
</div>
</li>
<li><p class="first">Start the server:</p>
<div class="highlight-python"><pre>$ brimd start</pre>
</div>
</li>
<li><p class="first">Access the &#8220;echo&#8221; app (echos <em>Just a test.</em> back):</p>
<div class="highlight-python"><pre>$ echo 'Just a test.' | nc -q 2 -u 127.0.0.1 8905</pre>
</div>
</li>
<li><p class="first">Stop the server:</p>
<div class="highlight-python"><pre>$ brimd stop</pre>
</div>
</li>
<li><p class="first">Create a multi-port ~/.brimd.conf:</p>
<div class="highlight-python"><pre>[udp]
port = 8905
call = brim.udp_echo.UDPEcho

[udp#alternate]
port = 8906
call = brim.udp_echo.UDPEcho</pre>
</div>
</li>
<li><p class="first">Start the server:</p>
<div class="highlight-python"><pre>$ brimd start</pre>
</div>
</li>
<li><p class="first">Access the &#8220;echo&#8221; apps (echo <em>Just a test.</em> back):</p>
<div class="highlight-python"><pre>$ echo 'Just a test.' | nc -q 2 -u 127.0.0.1 8905
$ echo 'Just a test.' | nc -q 2 -u 127.0.0.1 8906</pre>
</div>
</li>
<li><p class="first">Stop the server:</p>
<div class="highlight-python"><pre>$ brimd stop</pre>
</div>
</li>
</ul>
<p>The included <a class="reference internal" href="brimdconfsample.html#brimdconfsample"><em>brimd.conf-sample</em></a> shows a full set of configuration options available for each subconfig and explains how the defaults usually fall back to the main conf.</p>
</div>
<div class="section" id="example-daemon-usage">
<h3>Example Daemon Usage<a class="headerlink" href="#example-daemon-usage" title="Permalink to this headline">¶</a></h3>
<p>The brimd server can manage additional daemons as well as the main WSGI server. You configure them much like WSGI apps, but with the daemons configuration value. There is a brim.daemon_sample.DaemonSample that can be a good start for writing new daemons.</p>
<p>Here&#8217;s an example brimd.conf that starts the sample daemon:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">daemons</span><span class="p">]</span>
<span class="n">daemons</span> <span class="o">=</span> <span class="n">sample</span>

<span class="p">[</span><span class="n">sample</span><span class="p">]</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">brim</span><span class="o">.</span><span class="n">daemon_sample</span><span class="o">.</span><span class="n">DaemonSample</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="development-examples">
<h2>Development Examples<a class="headerlink" href="#development-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="wsgi-application-development">
<h3>WSGI Application Development<a class="headerlink" href="#wsgi-application-development" title="Permalink to this headline">¶</a></h3>
<p>Developing WSGI applications for brimd is quite similar to other Python WSGI servers. Here&#8217;s a simple example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">next_app</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_app</span> <span class="o">=</span> <span class="n">next_app</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">env</span><span class="p">[</span><span class="s">&#39;PATH_INFO&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;/helloworld&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_app</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="s">&#39;Hello World!</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">start_response</span><span class="p">(</span><span class="s">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;Content-Length&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)))])</span>
        <span class="k">return</span> <span class="n">body</span>
</pre></div>
</div>
<p>Here&#8217;s an example ~/.brimd.conf with this app active:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">wsgi</span><span class="p">]</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8901</span>
<span class="n">apps</span> <span class="o">=</span> <span class="n">helloworld</span>

<span class="p">[</span><span class="n">helloworld</span><span class="p">]</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">mypackage</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">HelloWorld</span>
</pre></div>
</div>
<p>We can then start the server and access the new app:</p>
<div class="highlight-python"><pre>$ brimd restart
$ curl -i http://127.0.0.1:8901/helloworld
HTTP/1.1 200 OK
Content-Length: 13
Date: Sat, 14 Jan 2012 22:57:38 GMT

Hello World!</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method is the usual WSGI (env, start_response) call made per incoming request.</p>
<p>The <tt class="docutils literal"><span class="pre">__init__</span></tt> is a little different for brimd and takes the name of the app as configured in the brimd.conf file, the full brimd configuration object as an instance of brim.conf.Conf, and the next WSGI app in the chain (the last app in the chain will always be brimd itself).</p>
<p>The name lets you know which part of the conf to access for any app-specific configuration, though you can always stray outside just that section if needed.</p>
<p>The conf, while by default is the full server brim.conf.Conf instance, it can be pre-parsed if desired. This is useful if you want to raise an exception if the configuration is invalid, preventing the server from starting with an explanatory message. Otherwise, once your app&#8217;s <tt class="docutils literal"><span class="pre">__init__</span></tt> method is called, you should not raise any exceptions unless something goes horribly wrong, as brimd will just keep restarting your app to try to keep it running.</p>
<p>To pre-parse the configuration, you just add a class method of parse_conf that takes the brim.conf.Conf instance and returns whatever you want as the conf argument to your constructor. To continue our example, we&#8217;ll look for a path in the config and exit if it doesn&#8217;t exist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">next_app</span><span class="p">):</span>
        <span class="c"># conf is what was returned from parse_conf now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_app</span> <span class="o">=</span> <span class="n">next_app</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">env</span><span class="p">[</span><span class="s">&#39;PATH_INFO&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_app</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="s">&#39;Hello World!</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">start_response</span><span class="p">(</span><span class="s">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;Content-Length&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)))])</span>
        <span class="k">return</span> <span class="n">body</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;path&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a path to serve.&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span>
</pre></div>
</div>
<p>Now, let&#8217;s restart the server without yet updating the config and see what happens:</p>
<div class="highlight-python"><pre>$ brimd restart
[helloworld] you must configure a path to serve.</pre>
</div>
<p>It&#8217;s important to note that this early config parsing is done in the main server process before any subprocesses are launched. Anything loaded into memory will copied into the subprocesses&#8217; memory as well. So, to reiterate, <tt class="docutils literal"><span class="pre">parse_conf</span></tt> is called in the main process and <tt class="docutils literal"><span class="pre">__init__</span></tt> is called in each subprocess.</p>
<p>Now, let&#8217;s update our configuration:</p>
<div class="highlight-python"><pre>[wsgi]
port = 8901
apps = helloworld

[helloworld]
call = mypackage.mymodule.HelloWorld
path = /here</pre>
</div>
<p>And now try using our app again:</p>
<div class="highlight-python"><pre>$ brimd restart
$ curl -i http://127.0.0.1:8901/here
HTTP/1.1 200 OK
Content-Length: 13
Date: Sat, 14 Jan 2012 23:05:20 GMT

Hello World!</pre>
</div>
<p>To continue our example, let&#8217;s add stats to our application. We&#8217;ll count how many times we&#8217;re called and the last time we were called:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>


<span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">next_app</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_app</span> <span class="o">=</span> <span class="n">next_app</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">env</span><span class="p">[</span><span class="s">&#39;PATH_INFO&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_app</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
        <span class="c"># Here&#39;s where we update the stats.</span>
        <span class="n">env</span><span class="p">[</span><span class="s">&#39;brim.stats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.requests&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">env</span><span class="p">[</span><span class="s">&#39;brim.stats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.last_called&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">())</span>
        <span class="n">body</span> <span class="o">=</span> <span class="s">&#39;Hello World!</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">start_response</span><span class="p">(</span><span class="s">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;Content-Length&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)))])</span>
        <span class="k">return</span> <span class="n">body</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;path&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a path to serve.&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">stats_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># This is the new class method to configure additional stats, it</span>
        <span class="c"># returns a list of (stat_name, stat_type) tuples.</span>
        <span class="k">return</span> <span class="p">[(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.requests&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="s">&#39;sum&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.last_called&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">,</span> <span class="s">&#39;max&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>You can see that we configure the stats with the new stats_conf class method. The method returns a list of (stat_name, stat_type) pairs. stat_name is the str name of the stat and stat_type is one of the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>worker</td>
<td>Indicates a worker only stat. No overall stat will be reported.</td>
</tr>
<tr class="row-even"><td>sum</td>
<td>Indicates an overall stat should be reported that is a sum of the stat from all workers.</td>
</tr>
<tr class="row-odd"><td>min</td>
<td>Indicates an overall stat should be reported that is the smallest value of the stat from all workers.</td>
</tr>
<tr class="row-even"><td>max</td>
<td>Indicates an overall stat should be reported that is the largest value of the stat from all workers.</td>
</tr>
</tbody>
</table>
<p>When handling actual requests, we can access the stats via the <tt class="docutils literal"><span class="pre">env['brim.stats']</span></tt> object, which supports the following methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>get(&lt;name&gt;)</td>
<td>Return the int value of the stat &lt;name&gt;.</td>
</tr>
<tr class="row-even"><td>set(&lt;name&gt;, value)</td>
<td>Sets the value of the stat &lt;name&gt;. The value will be treated as an unsigned integer.</td>
</tr>
<tr class="row-odd"><td>incr(&lt;name&gt;)</td>
<td>Increments the value of the stat &lt;name&gt; by 1.</td>
</tr>
</tbody>
</table>
<p>So now, let&#8217;s add the brim.wsgi_stats.WSGIStats app to our configuration so we&#8217;ll be able to get a report on the server stats; we&#8217;ll also set up two workers to show the separate worker stats:</p>
<div class="highlight-python"><pre>[wsgi]
port = 8901
apps = helloworld stats
workers = 2

[helloworld]
call = mypackage.mymodule.HelloWorld
path = /here

[stats]
call = brim.wsgi_stats.WSGIStats</pre>
</div>
<p>Let&#8217;s try it out:</p>
<div class="highlight-python"><pre>$ brimd restart
$ curl http://127.0.0.1:8901/here
Hello World!
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "wsgi": {
        "0": {
            "helloworld.last_called": 0,
            "helloworld.requests": 0,
...
        "1": {
            "helloworld.last_called": 1330399869,
            "helloworld.requests": 1,
...
        "helloworld.last_called": 1330399869,
        "helloworld.requests": 1,
...
$ curl http://127.0.0.1:8901/here
Hello World!
$ curl http://127.0.0.1:8901/here
Hello World!
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "wsgi": {
        "0": {
            "helloworld.last_called": 0,
            "helloworld.requests": 0,
...
        "1": {
            "helloworld.last_called": 1330399935,
            "helloworld.requests": 3,
...
        "helloworld.last_called": 1330399935,
        "helloworld.requests": 3,
...</pre>
</div>
<p>With very low load, a single worker often gets all the requests. If you have Apache Bench installed you might try that to get a better load test:</p>
<div class="highlight-python"><pre>$ ab -n 12345 http://127.0.0.1:8901/here
...
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "wsgi": {
        "0": {
            "helloworld.last_called": 1330399999,
            "helloworld.requests": 6201,
...
        "1": {
            "helloworld.last_called": 1330399999,
            "helloworld.requests": 6147,
...
        "helloworld.last_called": 1330399999,
        "helloworld.requests": 12348,
...</pre>
</div>
<div class="section" id="extra-wsgi-env-items">
<h4>Extra WSGI env Items<a class="headerlink" href="#extra-wsgi-env-items" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>brim</td>
<td>This is the <a class="reference internal" href="api.html#brim.server.Server" title="brim.server.Server"><tt class="xref py py-class docutils literal"><span class="pre">brim.server.Server</span></tt></a> instance itself. Normally you don&#8217;t need access to this, but some apps like <a class="reference internal" href="api.html#brim.wsgi_stats.WSGIStats" title="brim.wsgi_stats.WSGIStats"><tt class="xref py py-class docutils literal"><span class="pre">brim.wsgi_stats.WSGIStats</span></tt></a> do.</td>
</tr>
<tr class="row-even"><td>brim.start</td>
<td>The time.time() the request started processing.</td>
</tr>
<tr class="row-odd"><td>brim.logger</td>
<td>A logging.Logger instance for most logging needs. This logger can be configured in brimd.conf and by default it logs at the INFO level and above to syslog&#8217;s LOCAL0 facility. Note that the server automatically logs request/responses at the NOTICE level, so you don&#8217;t have to.</td>
</tr>
<tr class="row-even"><td>brim.txn</td>
<td>A uuid.uuid4().hex value to unique identify the request. This can be very useful when logging so that you can track what a request is doing on a busy server. This is automatically added to every log line the brim.logger logs.</td>
</tr>
<tr class="row-odd"><td>brim.log_info</td>
<td><p class="first">A list of strings that will be appended to the request log line that brimd generates. This can be useful for identifying requests or what actions requests may have taken.</p>
<p>It&#8217;s usually best to add your app&#8217;s info all at once with a prefix word, like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">env</span><span class="p">[</span><span class="s">&#39;brim.log_info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&#39;myapp:&#39;</span><span class="p">,</span> <span class="s">&#39;myinfo1&#39;</span><span class="p">,</span> <span class="s">&#39;myinfo2&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>You could just add it all as one word:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">env</span><span class="p">[</span><span class="s">&#39;brim.log_info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;myapp: myinfo1 myinfo2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">But understand that this will encode the spaces to %20 on the log line.</p>
</td>
</tr>
<tr class="row-even"><td>brim.stats</td>
<td><p class="first">An object that gives access to server stats. Which stats are available is determined by the server configuration, and specifically by each app&#8217;s stats_conf class method. See the <a class="reference internal" href="api.html#brim.wsgi_echo.WSGIEcho" title="brim.wsgi_echo.WSGIEcho"><tt class="xref py py-class docutils literal"><span class="pre">brim.wsgi_echo.WSGIEcho</span></tt></a> and <a class="reference internal" href="api.html#brim.wsgi_stats.WSGIStats" title="brim.wsgi_stats.WSGIStats"><tt class="xref py py-class docutils literal"><span class="pre">brim.wsgi_stats.WSGIStats</span></tt></a> apps for examples of how to use these stats. This stats object will implement at least the following methods:</p>
<div class="last highlight-python"><pre>get(&lt;name&gt;)         Return the int value of the
                    stat &lt;name&gt;.
set(&lt;name&gt;, int)    Sets the int value of the
                    stat &lt;name&gt;. The value will
                    be treated as unsigned.
incr(&lt;name&gt;)        Increments the value of the
                    stat &lt;name&gt; by 1.</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>brim.json_dumps</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>brim.json_loads</td>
<td>These are the JSON dumps and loads functions for converting to and from JSON and Python objects. By default, these are json.dumps and json.loads, but faster libraries are out there and can be configured in brimd.conf. Using these env items means you&#8217;ll automatically use whatever is configured.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="server-stats">
<h4>Server Stats<a class="headerlink" href="#server-stats" title="Permalink to this headline">¶</a></h4>
<p>The brimd server tracks various statistics, such as the server start time and number of requests processed. The <a class="reference internal" href="api.html#brim.wsgi_stats.WSGIStats" title="brim.wsgi_stats.WSGIStats"><tt class="xref py py-class docutils literal"><span class="pre">brim.wsgi_stats.WSGIStats</span></tt></a> app can be configured to provide access to these stats via a JSON response:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">wsgi</span><span class="p">]</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8901</span>
<span class="n">apps</span> <span class="o">=</span> <span class="n">stats</span>
<span class="n">workers</span> <span class="o">=</span> <span class="mi">2</span>

<span class="p">[</span><span class="n">stats</span><span class="p">]</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">brim</span><span class="o">.</span><span class="n">wsgi_stats</span><span class="o">.</span><span class="n">WSGIStats</span>
<span class="c"># path = &lt;path&gt;</span>
<span class="c">#   The request path to match and serve; any other paths will be passed on</span>
<span class="c">#   to the next WSGI app in the chain. This can serve as a basic</span>
<span class="c">#   restriction to accessing the stats by setting it to a hard to guess</span>
<span class="c">#   value. Default: /stats</span>
</pre></div>
</div>
<p>After restarting the server, you can now access these stats:</p>
<div class="highlight-python"><pre>$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
{
    "start_time": 1330395908,
    "wsgi": {
        "0": {
            "request_count": 29243,
            "start_time": 1330395908,
            "status_2xx_count": 22995,
            "status_4xx_count": 6248
        },
        "1": {
            "request_count": 29453,
            "start_time": 1330395908,
            "status_2xx_count": 23358,
            "status_4xx_count": 6095
        },
        "request_count": 58696,
        "status_2xx_count": 46353,
        "status_4xx_count": 12343
    }
}</pre>
</div>
<p>Notice there are overall server stats and individual worker stats. Here is what&#8217;s available by default (apps can configure additional stats):</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>request_count</td>
<td>This is the number of requests served by the server and is simply a sum of all the worker&#8217;s request_counts.</td>
</tr>
<tr class="row-even"><td>start_time</td>
<td>This is the <tt class="docutils literal"><span class="pre">int(time.time())</span></tt> the server was started. Each worker also has a start_time that indicates when that subprocess was started. If a subprocess crashes and restarts, this start_time will be different than the overall server start_time.</td>
</tr>
<tr class="row-odd"><td>status_2xx_count</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>status_3xx_count</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>status_4xx_count</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>status_5xx_count</td>
<td>These are the counts of requests that returned the response code ranges stated. For example, a high status_5xx_count can indicate a major server problem.</td>
</tr>
<tr class="row-odd"><td>status_404_count</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>status_408_count</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>etc.</td>
<td>These track specific response codes. Which response codes are tracked can be configured in brimd.conf, but are 404, 408, 499, and 501 by default. A high 404 count on a server that normally shouldn&#8217;t do so can indicate missing files or a bad incoming link. 408 Request Timeout and 499 Disconnect can indicate network problems or perhaps too aggressive timeouts. 501 Not Implemented counts can often be subtracted from the status_5xx_count to get a true count of real server problems.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="tcp-straight-socket-application-development">
<h3>TCP Straight Socket Application Development<a class="headerlink" href="#tcp-straight-socket-application-development" title="Permalink to this headline">¶</a></h3>
<p>Developing brimd straight TCP socket applications is very simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">&#39;Hello World!</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>You&#8217;d probably want a lot of error checking in your call, but this works for now. So let&#8217;s set up an ~/.brimd.conf to run this application:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">tcp</span><span class="p">]</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8903</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">mypackage</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">HelloWorld</span>
</pre></div>
</div>
<p>We can then start the server and access the new app:</p>
<div class="highlight-python"><pre>$ brimd restart
$ nc -q 2 127.0.0.1 8903
Hello World!</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method is called for each incoming connection with the subserver, stats, socket, ip, and port of the connection. The subserver is the <a class="reference internal" href="api.html#brim.server.TCPSubserver" title="brim.server.TCPSubserver"><tt class="xref py py-class docutils literal"><span class="pre">brim.server.TCPSubserver</span></tt></a> that accepted the request; usually you just use the logger attribute of this class. The stats will be explained a bit further down. The socket, ip, and port represent the just established TCP connection.</p>
<p>The <tt class="docutils literal"><span class="pre">__init__</span></tt> takes the name of the app as configured in the brimd.conf file, and the full brimd configuration object as an instance of <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a>.</p>
<p>The name lets you know which part of the conf to access for any app-specific configuration, though you can always stray outside just that section if needed.</p>
<p>The conf, while by default is the full server <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a> instance, it can be pre-parsed if desired. This is useful if you want to raise an exception if the configuration is invalid, preventing the server from starting with an explanatory message. Otherwise, once your app&#8217;s <tt class="docutils literal"><span class="pre">__init__</span></tt> method is called, you should not raise any exceptions unless something goes horribly wrong, as brimd will just keep restarting your app to try to keep it running.</p>
<p>To pre-parse the configuration, you just add a class method of parse_conf that takes the <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a> instance and returns whatever you want as the conf argument to your constructor. To continue our example, we&#8217;ll look for a message in the config and exit if it doesn&#8217;t exist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># conf is what was returned from parse_conf now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;message&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a message to serve.&#39;</span> <span class="o">%</span>
                            <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">message</span>
</pre></div>
</div>
<p>Now, let&#8217;s restart the server without yet updating the config and see what happens:</p>
<div class="highlight-python"><pre>$ brimd restart
[tcp] you must configure a message to serve.</pre>
</div>
<p>It&#8217;s important to note that this early config parsing is done in the main server process before any subprocesses are launched. Anything loaded into memory will copied into the subprocesses&#8217; memory as well. So, to reiterate, <tt class="docutils literal"><span class="pre">parse_conf</span></tt> is called in the main process and <tt class="docutils literal"><span class="pre">__init__</span></tt> is called in each subprocess.</p>
<p>Now, let&#8217;s update our configuration:</p>
<div class="highlight-python"><pre>[tcp]
port = 8903
call = mypackage.mymodule.HelloWorld
message = Hello, hello!</pre>
</div>
<p>And now try using our app again:</p>
<div class="highlight-python"><pre>$ brimd restart
$ nc -q 2 127.0.0.1 8903
Hello, hello!</pre>
</div>
<p>To continue our example, let&#8217;s add stats to our application. We&#8217;ll count how many times we&#8217;re called and the last time we were called:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>


<span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># conf is what was returned from parse_conf now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c"># Here&#39;s where we update the stats.</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.connections&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.last_called&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;message&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a message to serve.&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">message</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">stats_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># This is the new class method to configure additional stats, it</span>
        <span class="c"># returns a list of (stat_name, stat_type) tuples.</span>
        <span class="k">return</span> <span class="p">[(</span><span class="s">&#39;connections&#39;</span><span class="p">,</span> <span class="s">&#39;sum&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;last_called&#39;</span><span class="p">,</span> <span class="s">&#39;max&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>You can see that we configure the stats with the new stats_conf class method. The method returns a list of (stat_name, stat_type) pairs. stat_name is the str name of the stat and stat_type is one of the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>worker</td>
<td>Indicates a worker only stat. No overall stat will be reported.</td>
</tr>
<tr class="row-even"><td>sum</td>
<td>Indicates an overall stat should be reported that is a sum of the stat from all workers.</td>
</tr>
<tr class="row-odd"><td>min</td>
<td>Indicates an overall stat should be reported that is the smallest value of the stat from all workers.</td>
</tr>
<tr class="row-even"><td>max</td>
<td>Indicates an overall stat should be reported that is the largest value of the stat from all workers.</td>
</tr>
</tbody>
</table>
<p>When handling actual requests, we can access the stats via the passed stats object, which supports the following methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>get(&lt;name&gt;)</td>
<td>Return the int value of the stat &lt;name&gt;.</td>
</tr>
<tr class="row-even"><td>set(&lt;name&gt;, value)</td>
<td>Sets the value of the stat &lt;name&gt;. The value will be treated as an unsigned integer.</td>
</tr>
<tr class="row-odd"><td>incr(&lt;name&gt;)</td>
<td>Increments the value of the stat &lt;name&gt; by 1.</td>
</tr>
</tbody>
</table>
<p>So now, let&#8217;s add the <a class="reference internal" href="api.html#brim.wsgi_stats.WSGIStats" title="brim.wsgi_stats.WSGIStats"><tt class="xref py py-class docutils literal"><span class="pre">brim.wsgi_stats.WSGIStats</span></tt></a> WSGI app to our configuration so we&#8217;ll be able to get a report on the server stats; we&#8217;ll also set up two workers to show the separate worker stats:</p>
<div class="highlight-python"><pre>[tcp]
port = 8903
call = mypackage.mymodule.HelloWorld
message = Hello, hello!
workers = 2

[wsgi]
port = 8901
apps = stats

[stats]
call = brim.wsgi_stats.WSGIStats</pre>
</div>
<p>Let&#8217;s try it out (note that the 0 values aren&#8217;t actually included in the stats output &#8211; it is assumed to be 0 if missing for brevity &#8211; but they&#8217;re included here for better understanding):</p>
<div class="highlight-python"><pre>$ brimd restart
$ nc -q 2 127.0.0.1 8903
Hello, hello!
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "tcp": {
        "0": {
...
            "connections": 1,
            "last_called": 1330399433
...
        "1": {
...
            "connections": 0,
            "last_called": 0
...
        "connections": 1,
        "last_called": 1330399433
...
$ nc -q 2 127.0.0.1 8903
Hello, hello!
$ nc -q 2 127.0.0.1 8903
Hello, hello!
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "tcp": {
        "0": {
...
            "connections": 3,
            "last_called": 1330399486
...
        "1": {
...
            "connections": 0,
            "last_called": 0
...
        "connections": 3,
        "last_called": 1330399486
...</pre>
</div>
<p>With very low load, a single worker often gets all the requests. You might try a simple for loop to try to generate some load:</p>
<div class="highlight-python"><pre>$ for x in {1..1234}; do nc 127.0.0.1 8903; done &gt; /dev/null
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "tcp": {
        "0": {
...
            "connections": 692,
            "last_called": 1330399723
...
        "1": {
...
            "connections": 545,
            "last_called": 1330399723
...
        "connections": 1237,
        "last_called": 1330399723
...</pre>
</div>
</div>
<div class="section" id="udp-socket-application-development">
<h3>UDP Socket Application Development<a class="headerlink" href="#udp-socket-application-development" title="Permalink to this headline">¶</a></h3>
<p>Developing brimd UDP socket applications is also very simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">datagram</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="s">&#39;Hello World!</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
</pre></div>
</div>
<p>You&#8217;d probably want a lot of error checking in your call, but this works for now. So let&#8217;s set up an ~/.brimd.conf to run this application:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">udp</span><span class="p">]</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8905</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">mypackage</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">HelloWorld</span>
</pre></div>
</div>
<p>We can then start the server and access the new app:</p>
<div class="highlight-python"><pre>$ brimd restart
$ echo 'test' | nc -u -q 2 127.0.0.1 8905
Hello World!</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method is called for each incoming datagram with the subserver, stats, datagram, socket, ip, and port of the datagram. The subserver is the <a class="reference internal" href="api.html#brim.server.UDPSubserver" title="brim.server.UDPSubserver"><tt class="xref py py-class docutils literal"><span class="pre">brim.server.UDPSubserver</span></tt></a> that accepted the request; usually you just use the logger attribute of this class. The stats will be explained a bit further down. The socket, ip, and port represent the just received datagram. The datagram is the payload of the UDP packet received.</p>
<p>The <tt class="docutils literal"><span class="pre">__init__</span></tt> takes the name of the app as configured in the brimd.conf file, and the full brimd configuration object as an instance of <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a>.</p>
<p>The name lets you know which part of the conf to access for any app-specific configuration, though you can always stray outside just that section if needed.</p>
<p>The conf, while by default is the full server <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a> instance, it can be pre-parsed if desired. This is useful if you want to raise an exception if the configuration is invalid, preventing the server from starting with an explanatory message. Otherwise, once your app&#8217;s <tt class="docutils literal"><span class="pre">__init__</span></tt> method is called, you should not raise any exceptions unless something goes horribly wrong, as brimd will just keep restarting your app to try to keep it running.</p>
<p>To pre-parse the configuration, you just add a class method of parse_conf that takes the <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a> instance and returns whatever you want as the conf argument to your constructor. To continue our example, we&#8217;ll look for a message in the config and exit if it doesn&#8217;t exist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># conf is what was returned from parse_conf now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">datagram</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;message&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a message to serve.&#39;</span> <span class="o">%</span>
                            <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">message</span>
</pre></div>
</div>
<p>Now, let&#8217;s restart the server without yet updating the config and see what happens:</p>
<div class="highlight-python"><pre>$ brimd restart
[udp] you must configure a message to serve.</pre>
</div>
<p>It&#8217;s important to note that this early config parsing is done in the main server process before any subprocesses are launched. Anything loaded into memory will copied into the subprocesses&#8217; memory as well. So, to reiterate, <tt class="docutils literal"><span class="pre">parse_conf</span></tt> is called in the main process and <tt class="docutils literal"><span class="pre">__init__</span></tt> is called in each subprocess.</p>
<p>Now, let&#8217;s update our configuration:</p>
<div class="highlight-python"><pre>[udp]
port = 8905
call = mypackage.mymodule.HelloWorld
message = Hello, hello!</pre>
</div>
<p>And now try using our app again:</p>
<div class="highlight-python"><pre>$ brimd restart
$ echo 'test' | nc -u -q 2 127.0.0.1 8905
Hello, hello!</pre>
</div>
<p>To continue our example, let&#8217;s add stats to our application. We&#8217;ll record the last time we were called:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>


<span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># conf is what was returned from parse_conf now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">datagram</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="c"># Here&#39;s where we update the stats.</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;last_called&#39;</span><span class="p">,</span> <span class="n">time</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;message&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a message to serve.&#39;</span> <span class="o">%</span>
                            <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">message</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">stats_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># This is the new class method to configure additional stats, it</span>
        <span class="c"># returns a list of (stat_name, stat_type) tuples.</span>
        <span class="k">return</span> <span class="p">[(</span><span class="s">&#39;last_called&#39;</span><span class="p">,</span> <span class="s">&#39;max&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>You can see that we configure the stats with the new stats_conf class method. The method returns a list of (stat_name, stat_type) pairs. stat_name is the str name of the stat and stat_type is one of the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>worker</td>
<td>Indicates a worker only stat. No overall stat will be reported.</td>
</tr>
<tr class="row-even"><td>sum</td>
<td>Indicates an overall stat should be reported that is a sum of the stat from all workers.</td>
</tr>
<tr class="row-odd"><td>min</td>
<td>Indicates an overall stat should be reported that is the smallest value of the stat from all workers.</td>
</tr>
<tr class="row-even"><td>max</td>
<td>Indicates an overall stat should be reported that is the largest value of the stat from all workers.</td>
</tr>
</tbody>
</table>
<p>When handling actual requests, we can access the stats via the passed stats object, which supports the following methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>get(&lt;name&gt;)</td>
<td>Return the int value of the stat &lt;name&gt;.</td>
</tr>
<tr class="row-even"><td>set(&lt;name&gt;, value)</td>
<td>Sets the value of the stat &lt;name&gt;. The value will be treated as an unsigned integer.</td>
</tr>
<tr class="row-odd"><td>incr(&lt;name&gt;)</td>
<td>Increments the value of the stat &lt;name&gt; by 1.</td>
</tr>
</tbody>
</table>
<p>So now, let&#8217;s add the brim.wsgi_stats.WSGIStats WSGI app to our configuration so we&#8217;ll be able to get a report on the server stats:</p>
<div class="highlight-python"><pre>[udp]
port = 8905
call = mypackage.mymodule.HelloWorld
message = Hello, hello!

[wsgi]
port = 8901
apps = stats

[stats]
call = brim.wsgi_stats.WSGIStats</pre>
</div>
<p>Let&#8217;s try it out:</p>
<div class="highlight-python"><pre>$ brimd restart
$ echo 'test' | nc -u -q 2 127.0.0.1 8905
Hello, hello!
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "udp": {
...
        "0": {
...
            "last_called": 1330401361,
...</pre>
</div>
</div>
<div class="section" id="daemon-development">
<h3>Daemon Development<a class="headerlink" href="#daemon-development" title="Permalink to this headline">¶</a></h3>
<p>Daemons for brimd are simply background processes you&#8217;d like brimd to ensure are running. If the daemon exits, it&#8217;ll just be restarted automatically. Developing daemons is quite simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>


<span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">subserver</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;sample log line </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>So let&#8217;s set up an ~/.brimd.conf to run this daemon:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">daemons</span><span class="p">]</span>
<span class="n">daemons</span> <span class="o">=</span> <span class="n">helloworld</span>

<span class="p">[</span><span class="n">helloworld</span><span class="p">]</span>
<span class="n">call</span> <span class="o">=</span> <span class="n">mypackage</span><span class="o">.</span><span class="n">mymodule</span><span class="o">.</span><span class="n">HelloWorld</span>
</pre></div>
</div>
<p>We can then start the server and monitor syslog to see the lines logged:</p>
<div class="highlight-python"><pre>$ brimd restart
$ sudo tail -F /var/log/syslog
Feb 27 20:16:08 lucid brimdaemons sample log line 1
...</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method is called to start the daemon subprocess with the subserver and stats object to use. The subserver is the <a class="reference internal" href="api.html#brim.server.DaemonsSubserver" title="brim.server.DaemonsSubserver"><tt class="xref py py-class docutils literal"><span class="pre">brim.server.DaemonsSubserver</span></tt></a> that started the subprocess; usually you just use the logger attribute of this class. The stats will be explained a bit further down.</p>
<p>The <tt class="docutils literal"><span class="pre">__init__</span></tt> takes the name of the daemon as configured in the brimd.conf file, and the full brimd configuration object as an instance of <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a>.</p>
<p>The name lets you know which part of the conf to access for any daemon-specific configuration, though you can always stray outside just that section if needed.</p>
<p>The conf, while by default is the full server <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a> instance, it can be pre-parsed if desired. This is useful if you want to raise an exception if the configuration is invalid, preventing the server from starting with an explanatory message. Otherwise, once your daemon&#8217;s <tt class="docutils literal"><span class="pre">__init__</span></tt> method is called, you should not raise any exceptions unless something goes horribly wrong, as brimd will just keep restarting your daemon to try to keep it running.</p>
<p>To pre-parse the configuration, you just add a class method of parse_conf that takes the <a class="reference internal" href="api.html#brim.conf.Conf" title="brim.conf.Conf"><tt class="xref py py-class docutils literal"><span class="pre">brim.conf.Conf</span></tt></a> instance and returns whatever you want as the conf argument to your constructor. To continue our example, we&#8217;ll look for a message in the config and exit if it doesn&#8217;t exist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>


<span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># conf is what was returned from parse_conf now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">subserver</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;message&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a message to log.&#39;</span> <span class="o">%</span>
                            <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">message</span>
</pre></div>
</div>
<p>Now, let&#8217;s restart the server without yet updating the config and see what happens:</p>
<div class="highlight-python"><pre>$ brimd restart
[helloworld] you must configure a message to log.</pre>
</div>
<p>It&#8217;s important to note that this early config parsing is done in the main server process before any subprocesses are launched. Anything loaded into memory will copied into the subprocesses&#8217; memory as well. So, to reiterate, <tt class="docutils literal"><span class="pre">parse_conf</span></tt> is called in the main process and <tt class="docutils literal"><span class="pre">__init__</span></tt> is called in each subprocess.</p>
<p>Now, let&#8217;s update our configuration:</p>
<div class="highlight-python"><pre>[daemons]
daemons = helloworld

[helloworld]
call = mypackage.mymodule.HelloWorld
message = Hello, hello!</pre>
</div>
<p>And now try running our daemon again:</p>
<div class="highlight-python"><pre>$ brimd restart
$ sudo tail -F /var/log/syslog
Feb 27 20:17:11 lucid brimdaemons Hello, hello! 1
...</pre>
</div>
<p>To continue our example, let&#8217;s add stats to our daemon. We&#8217;ll record the last time we logged:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span><span class="p">,</span> <span class="n">time</span>


<span class="k">class</span> <span class="nc">HelloWorld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># conf is what was returned from parse_conf now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subserver</span><span class="p">,</span> <span class="n">stats</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">subserver</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
            <span class="c"># Here&#39;s where we update the stats.</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;last_logged&#39;</span><span class="p">,</span> <span class="n">time</span><span class="p">())</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parse_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;message&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;[</span><span class="si">%s</span><span class="s">] you must configure a message to log.&#39;</span> <span class="o">%</span>
                            <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">message</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">stats_conf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="c"># This is the new class method to configure additional stats, it</span>
        <span class="c"># returns a list of (stat_name, stat_type) tuples.</span>
        <span class="k">return</span> <span class="p">[(</span><span class="s">&#39;last_logged&#39;</span><span class="p">,</span> <span class="s">&#39;daemon&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>You can see that we configure the stats with the new stats_conf class method. The method returns a list of (stat_name, stat_type) pairs. stat_name is the str name of the stat and stat_type is one of the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>daemon</td>
<td>Indicates a daemon only stat. No overall stat will be reported.</td>
</tr>
<tr class="row-even"><td>sum</td>
<td>Indicates an overall stat should be reported that is a sum of the stat from all daemons.</td>
</tr>
<tr class="row-odd"><td>min</td>
<td>Indicates an overall stat should be reported that is the smallest value of the stat from all daemons.</td>
</tr>
<tr class="row-even"><td>max</td>
<td>Indicates an overall stat should be reported that is the largest value of the stat from all daemons.</td>
</tr>
</tbody>
</table>
<p>We can access the stats via the passed stats object, which supports the following methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>get(&lt;name&gt;)</td>
<td>Return the int value of the stat &lt;name&gt;.</td>
</tr>
<tr class="row-even"><td>set(&lt;name&gt;, value)</td>
<td>Sets the value of the stat &lt;name&gt;. The value will be treated as an unsigned integer.</td>
</tr>
<tr class="row-odd"><td>incr(&lt;name&gt;)</td>
<td>Increments the value of the stat &lt;name&gt; by 1.</td>
</tr>
</tbody>
</table>
<p>So now, let&#8217;s add the <a class="reference internal" href="api.html#brim.wsgi_stats.WSGIStats" title="brim.wsgi_stats.WSGIStats"><tt class="xref py py-class docutils literal"><span class="pre">brim.wsgi_stats.WSGIStats</span></tt></a> WSGI app to our configuration so we&#8217;ll be able to get a report on the server stats:</p>
<div class="highlight-python"><pre>[daemons]
daemons = helloworld

[helloworld]
call = mypackage.mymodule.HelloWorld
message = Hello, hello!

[wsgi]
port = 8901
apps = stats

[stats]
call = brim.wsgi_stats.WSGIStats</pre>
</div>
<p>Let&#8217;s try it out:</p>
<div class="highlight-python"><pre>$ brimd restart
$ sudo tail -F /var/log/syslog
Feb 27 20:18:33 lucid brimdaemons Hello, hello! 1
...
$ curl -s http://127.0.0.1:8901/stats | python -mjson.tool
...
    "daemons": {
...
        "helloworld" {
...
            "last_logged": 1330402713,
...</pre>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Brim.Net Core Package</a><ul>
<li><a class="reference internal" href="#api">API</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#required-dependencies">Required Dependencies</a></li>
<li><a class="reference internal" href="#optional-dependencies">Optional Dependencies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#usage-examples">Usage Examples</a><ul>
<li><a class="reference internal" href="#example-wsgi-usage">Example WSGI Usage</a></li>
<li><a class="reference internal" href="#example-wsgi-multi-configuration-usage">Example WSGI Multi-Configuration Usage</a></li>
<li><a class="reference internal" href="#example-tcp-straight-socket-application-usage">Example TCP Straight Socket Application Usage</a></li>
<li><a class="reference internal" href="#example-udp-application-usage">Example UDP Application Usage</a></li>
<li><a class="reference internal" href="#example-daemon-usage">Example Daemon Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#development-examples">Development Examples</a><ul>
<li><a class="reference internal" href="#wsgi-application-development">WSGI Application Development</a><ul>
<li><a class="reference internal" href="#extra-wsgi-env-items">Extra WSGI env Items</a></li>
<li><a class="reference internal" href="#server-stats">Server Stats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tcp-straight-socket-application-development">TCP Straight Socket Application Development</a></li>
<li><a class="reference internal" href="#udp-socket-application-development">UDP Socket Application Development</a></li>
<li><a class="reference internal" href="#daemon-development">Daemon Development</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Next topic</h4>
  <p class="topless"><a href="readme.html"
                        title="next chapter">README</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="readme.html" title="README"
             >next</a> |</li>
        <li><a href="#">Brim.Net Core Package 0.05 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Gregory Holt, portions (httpform) 2011 OpenStack, LLC..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b3.
    </div>
  </body>
</html>